<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2017-10-30T17:08:03+08:00</updated><id>http://localhost:4000/</id><title type="html">Leon Sun</title><subtitle>Blog and website of Leon Sun</subtitle><author><name>Leon Sun</name></author><entry><title type="html">NLDM vs. CCS</title><link href="http://localhost:4000/NLDM-VS-CCS/" rel="alternate" type="text/html" title="NLDM vs. CCS" /><published>2017-10-25T00:00:00+08:00</published><updated>2017-10-25T00:00:00+08:00</updated><id>http://localhost:4000/NLDM-VS-CCS</id><content type="html" xml:base="http://localhost:4000/NLDM-VS-CCS/">&lt;p&gt;上篇里提到了，一些负面效应在advanced node下越来越明显，这些效应也使传统的NLDM model越来越不精确。Synopsys提出了Composite Current Source(CCS)，CCS是基于电流源模型，集timing/power/noise于一体，精确度更高，与SPICE的误差可以达到±2%。&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-cell-model&quot;&gt;1. cell model&lt;/h2&gt;
&lt;p&gt;集成电路设计是典型的hierarchical design：PMOS/NMOS –&amp;gt; std cell –&amp;gt; design module –&amp;gt; block –&amp;gt; chip。每一次的低层抽象过程，都要抽取出logic和physical信息，以供高层使用。&lt;br /&gt;
physical上的抽象，一般是def/lef/frame等，这些都是对GDS的简化。&lt;br /&gt;
logic上，一般会包括timing、power、noise等信息。&lt;br /&gt;
从最底层的MOS管抽象出std cell，就是cell model过程; 从MOS管提取出的timing、power、noise信息写入lib/db file，供上层做STA/SPA/SNA等分析。90nm以前，一般用NLDM/NLPM/NLNM(Nonlinear Delay/Power/Noise Model)。但是advanced node下，NLDM的精确度差，常用的model有:CCS(synopsys) 和 ECS(cadence)。 &lt;br /&gt;
Block的logic信息也要抽象出来供top使用，常见的抽象block timing模型有：block abstract model(BAM)、extract timing model(ETM)、interface logic models(ILM)等。&lt;/p&gt;

&lt;h2 id=&quot;2-nldm&quot;&gt;2. NLDM&lt;/h2&gt;
&lt;p&gt;Cell model过程是把一个std cell看成block box，只考虑其input/output pin。其input pin对外部是receiver; output pin对外部是driver。Cell model都需要对receiver/driver分别建立模型，得到的模型结果越接近真实值，则精确度更高。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017-10-25_nldm.png&quot; alt=&quot;NLDM driver/receiver model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NLDM的driver model是一个内阻恒定的电压源，即输出电压是时间的线性函数，V(t)。这是可以理解的，因为对于driver model，仅考虑stdcell最后一个MOS管，回忆一下，MOS管在导通时要经过多子减少、反型、少子继续积累至饱和，在I-V曲线上就表现为截止区、线性区和饱和区。在线性区上，MOS管电阻可以近似的看成定值(只是近似，其实除了线性关系，还有个二次函数关系,所以电阻其实是逐渐变大的)。这段线性区的过程，在数字集成电路中，就是transition time。所以，NLDM模型认为cell outout pin从0到1过程中，V是线性地从0到VDD。&lt;br /&gt;
NLDM的receiver model是一个恒定的input cap。&lt;br /&gt;
NLDM虽然很简单，但是随着工艺节点下降，金属电阻、寄生电容都越来越大，其精确度也就变差。对于NLDM driver model，当其后面的金属电阻/电容变大时，线性区的电阻是变大的，而且，V越接近VDD，电阻值越大，所以其实driver transition time 变大，cell delay变大。对于NLDM receiver model，在advanced node下，Miller效应影响更明显，单一的input cap也无法正确表征。如下图，可以看出在0.6V前后，曲线曲率明显不同，对应cap值分别为23/31，这无法用单一的input cap表示。&lt;br /&gt;
&lt;img src=&quot;/img/2017-10-25_ccs_input_cap.png&quot; alt=&quot;NLDM input cap&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-ccs&quot;&gt;3. CCS&lt;/h2&gt;
&lt;p&gt;CCS就是为了解决这些偏差而生的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017-10-25_ccs.png&quot; alt=&quot;CCS driver/receiver model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CCS driver model是一个非线性复合电流源，电流随电压和时间而变化，I(t,V)，可以更精确地处理高电感负载。不仅如此，CCS dirver还能更好地处理非单调波形。 &lt;br /&gt;
CCS receiver model是由两个cap值表示，它们随着transition而变化。C1,C2分别是transition前后半段的cap值。比如input pin的trip points是30%和70%，那么(30%,50%)这段时间的cap值为C1，(50%,70%)这段时间的cap值为C2，STA tool会动态选择cap值。如下图，C1/C2值还是能很好的拟合实际情形。 &lt;br /&gt;
&lt;img src=&quot;/img/2017-10-25_ccs_input_cap.png&quot; alt=&quot;NLDM input cap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外，CCS lib/db里，可以同时含timing/power/noise信息。CCS lib里会看到有ccsn_first_stage/ccsn_last_stage group，分别是最前/后级管子受noise的影响。&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="STA" /><summary type="html">上篇里提到了，一些负面效应在advanced node下越来越明显，这些效应也使传统的NLDM model越来越不精确。Synopsys提出了Composite Current Source(CCS)，CCS是基于电流源模型，集timing/power/noise于一体，精确度更高，与SPICE的误差可以达到±2%。</summary></entry><entry><title type="html">Clock Gating Check</title><link href="http://localhost:4000/clock-gating-check/" rel="alternate" type="text/html" title="Clock Gating Check" /><published>2017-10-02T00:00:00+08:00</published><updated>2017-10-02T00:00:00+08:00</updated><id>http://localhost:4000/clock-gating-check</id><content type="html" xml:base="http://localhost:4000/clock-gating-check/">&lt;p&gt;Clock gating check是一种常见的时序检查，当gating signal控制clock signal时，其跳变必须满足时序要求以得到想要的gated clock。最常见的gating check发生在ICG cell上。ICG是常见的low power解决方案，通过在clock tree上插入ICG cell，来减少ICG后面clock buffer/register的不必要跳变，从而起到降低功耗的目的。其实，只要是多输入逻辑cell，只要满足两个条件，都需要做gating check。&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id=&quot;1clock-gating-check-的必要条件&quot;&gt;1.clock gating check 的必要条件&lt;/h2&gt;
&lt;p&gt;clock gating check必须满足两个条件：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;clock pin上必须是&lt;strong&gt;有效clock signal&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;gating pin上必须是&lt;strong&gt;无效clock signal&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里的&lt;strong&gt;有效clock signal&lt;/strong&gt;是博主为了方便理解生造出来的。&lt;strong&gt;有效clock signal&lt;/strong&gt;并不是仅仅说这个clock pin上有clock attribute,而且它的fanout必须至少满足以下之一：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;有register的clock pin;&lt;/li&gt;
  &lt;li&gt;有output port;&lt;/li&gt;
  &lt;li&gt;有以clock pin所属clock的generated clock的sink.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与之对应，gating pin必须是data signal或者不满足上面三个条件的clock signal。 &lt;br /&gt;
只有满足了clock pin和gating pin都满足要求，才会对这个logic cell做gating check。  &lt;br /&gt;
SDC里，我们用&lt;code&gt;set_clock_gating_check&lt;/code&gt;往往不能完全覆盖所有需要gating check的logic cell，这时工具会根据上文的gating check必要条件来推断需要gating check的点。&lt;/p&gt;

&lt;h2 id=&quot;2两种clock-gating-check&quot;&gt;2.两种clock gating check&lt;/h2&gt;
&lt;p&gt;以与门和或门为代表，有两种类型的gating check：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;active-high clock gating check: gating signal为1时，clock signal可以穿过logic cell。比如AND/NAND cell。&lt;/li&gt;
  &lt;li&gt;active-low  clock gating check: gating signal为0时，clock signal可以穿过logic cell。比如OR/NOR cell。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3case-example&quot;&gt;3.case example&lt;/h2&gt;
&lt;p&gt;为了验证clock gating check，需要写一个简单的test module,verilog 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-verilog&quot;&gt;module test ( A, CLK, OUT);
input A;
input CLK;
output OUT;

DFQD2BWP7T40P140HVT reg0 (.D(A), .CP(CLK), .Q(reg0out));
AN2D2BWP7T40P140HVT and1 (.A1(CLK), .A2(reg0out), .Z(and1out));
AN2D2BWP7T40P140HVT and2 (.A1(CLK), .A2(reg0out), .Z(and2out));
AN2D2BWP7T40P140HVT and3 (.A1(CLK), .A2(reg0out), .Z(OUT));
DFQD2BWP7T40P140HVT reg1 (.D(and1out), .CP(A), .Q());
DFQD2BWP7T40P140HVT reg2 (.D(A), .CP(and2out), .Q());

endmodule
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;电路图如下：
&lt;img src=&quot;/img/2017-10-02_1.png&quot; alt=&quot;电路图&quot; /&gt;
在port CLK处定义clock myclk，然后report timing :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pt_shell&amp;gt; create_clock -name myclk -period 2 [get_ports CLK]
1
pt_shell&amp;gt; report_timing -to and1/A2 -group **clock_gating_default**
****************************************
Report : timing
        -path_type full
        -delay_type max
        -max_paths 1
        -group **clock_gating_default**
        -sort_by slack
Design : test
Version: I-2013.12
Date   : Fri Oct  6 17:43:59 2017
****************************************

Warning: There is 1 invalid end point for constrained paths. (UITE-416)
Warning: There is 1 invalid end point for unconstrained paths. (UITE-416)
No Paths.

1
pt_shell&amp;gt; report_timing -to and2/A2 -group **clock_gating_default**
****************************************
Report : timing
        -path_type full
        -delay_type max
        -max_paths 1
        -group **clock_gating_default**
        -sort_by slack
Design : test
Version: I-2013.12
Date   : Fri Oct  6 17:43:15 2017
****************************************


  Startpoint: reg0 (rising edge-triggered flip-flop clocked by myclk)
  Endpoint: and2 (rising clock gating-check end-point clocked by myclk)
  Path Group: **clock_gating_default**
  Path Type: max

  Point                                    Incr       Path
  ---------------------------------------------------------------
  clock myclk (rise edge)                  0.00       0.00
  clock network delay (ideal)              0.00       0.00
  reg0/CP (DFQD2BWP7T40P140HVT)            0.00       0.00 r
  reg0/Q (DFQD2BWP7T40P140HVT)             0.13       0.13 f
  and2/A2 (AN2D2BWP7T40P140HVT)            0.00       0.13 f
  data arrival time                                   0.13

  clock myclk (rise edge)                  2.00       2.00
  clock network delay (ideal)              0.00       2.00
  clock reconvergence pessimism            0.00       2.00
  and2/A1 (AN2D2BWP7T40P140HVT)                       2.00 r
  clock gating setup time                  0.00       2.00
  data required time                                  2.00
  ---------------------------------------------------------------
  data required time                                  2.00
  data arrival time                                  -0.13
  ---------------------------------------------------------------
  slack (MET)                                         1.87


1
pt_shell&amp;gt; report_timing -to and3/A2 -group **clock_gating_default**
****************************************
Report : timing
        -path_type full
        -delay_type max
        -max_paths 1
        -group **clock_gating_default**
        -sort_by slack
Design : test
Version: I-2013.12
Date   : Fri Oct  6 17:43:32 2017
****************************************

  Point                                    Incr       Path
  ---------------------------------------------------------------
  clock myclk (rise edge)                  0.00       0.00
  clock network delay (ideal)              0.00       0.00
  reg0/CP (DFQD2BWP7T40P140HVT)            0.00       0.00 r
  reg0/Q (DFQD2BWP7T40P140HVT)             0.13       0.13 f
  and3/A2 (AN2D2BWP7T40P140HVT)            0.00       0.13 f
  data arrival time                                   0.13

  clock myclk (rise edge)                  2.00       2.00
  clock network delay (ideal)              0.00       2.00
  clock reconvergence pessimism            0.00       2.00
  and3/A1 (AN2D2BWP7T40P140HVT)                       2.00 r
  clock gating setup time                  0.00       2.00
  data required time                                  2.00
  ---------------------------------------------------------------
  data required time                                  2.00
  data arrival time                                  -0.13
  ---------------------------------------------------------------
  slack (MET)                                         1.87


1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这三个与门,都是A1 pin为clock pin, A2 pin位gating pin。&lt;br /&gt;
and2/A1的fanout有reg2/CP，为myclk的sink，所以and2/A1是&lt;strong&gt;有效clock signal&lt;/strong&gt;, and1需要clock gating check;&lt;br /&gt;
and3/A1的fanout有output port OUT，所以and3/A1也是&lt;strong&gt;有效clock singal&lt;/strong&gt;, and3需要clock gating check; &lt;br /&gt;
and1/A1的fanout既没有clock sink，也没有output port，所以and1不需要clock gating check. &lt;br /&gt;
如果在and2后面定义clock呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pt_shell&amp;gt; create_clock -name myclk2 -period 2 and2/Z
Warning: Creating a clock on internal pin 'and2/Z'. (UITE-130)
1
pt_shell&amp;gt; report_timing -to and2/A2 -group **clock_gating_default**
Warning: No clock-gating check was inferred for clock myclk at pins and2/A2 and and2/A1 of cell and2 because no clock pins could be found in the fanout for the propagating clock. (PTE-101)
Information: Abandoning fast timing updates. (PTE-018)
Information: Inferring 1 clock-gating checks. (PTE-017)
****************************************
Report : timing
        -path_type full
        -delay_type max
        -max_paths 1
        -group **clock_gating_default**
        -sort_by slack
Design : test
Version: I-2013.12
Date   : Fri Oct  6 18:12:49 2017
****************************************

Warning: There is 1 invalid end point for constrained paths. (UITE-416)
Warning: There is 1 invalid end point for unconstrained paths. (UITE-416)

  Startpoint: reg0 (rising edge-triggered flip-flop clocked by myclk)
  Endpoint: and2/Z (internal pin)
  Path Group: (none)
  Path Type: max

  Point                                    Incr       Path
  ---------------------------------------------------------------
  reg0/CP (DFQD2BWP7T40P140HVT)            0.00       0.00 r
  reg0/Q (DFQD2BWP7T40P140HVT)             0.11       0.11 r
  and2/A2 (AN2D2BWP7T40P140HVT) &amp;lt;-         0.00       0.11 r
  and2/Z (AN2D2BWP7T40P140HVT)             0.05       0.17 r
  data arrival time                                   0.17
  ---------------------------------------------------------------
  (Path is unconstrained)


1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and2/A1有myclk，但是后面fanout没有myclk的sink。所以没有clock gating check。
再试一下在and2/Z定义myclk的generated clock。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
pt_shell&amp;gt; create_generated_clock -name myclk_gen1 -source CLK -divide_by 1 and2/Z
Information: Abandoning fast timing updates. (PTE-018)
1
pt_shell&amp;gt; report_timing -to and2/A2 -group **clock_gating_default**
Information: Inferring 2 clock-gating checks. (PTE-017)
Information: Using automatic max wire load selection group 'WireAreaForZero'. (ENV-003)
Information: Using automatic min wire load selection group 'WireAreaForZero'. (ENV-003)
****************************************
Report : timing
        -path_type full
        -delay_type max
        -max_paths 1
        -group **clock_gating_default**
        -sort_by slack
Design : test
Version: I-2013.12
Date   : Fri Oct  6 18:17:01 2017
****************************************


  Startpoint: reg0 (rising edge-triggered flip-flop clocked by myclk)
  Endpoint: and2 (rising clock gating-check end-point clocked by myclk)
  Path Group: **clock_gating_default**
  Path Type: max

  Point                                    Incr       Path
  ---------------------------------------------------------------
  clock myclk (rise edge)                  0.00       0.00
  clock network delay (ideal)              0.00       0.00
  reg0/CP (DFQD2BWP7T40P140HVT)            0.00       0.00 r
  reg0/Q (DFQD2BWP7T40P140HVT)             0.13       0.13 f
  and2/A2 (AN2D2BWP7T40P140HVT)            0.00       0.13 f
  data arrival time                                   0.13

  clock myclk (rise edge)                  2.00       2.00
  clock network delay (ideal)              0.00       2.00
  clock reconvergence pessimism            0.00       2.00
  and2/A1 (AN2D2BWP7T40P140HVT)                       2.00 r
  clock gating setup time                  0.00       2.00
  data required time                                  2.00
  ---------------------------------------------------------------
  data required time                                  2.00
  data arrival time                                  -0.13
  ---------------------------------------------------------------
  slack (MET)                                         1.87


1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然and2是有clock gating check，因为and2/A1满足&lt;strong&gt;有效clock signal&lt;/strong&gt;的第三个条件。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;虽然PT会infer clock gating check，但是我们还是要理解其原因。只要记住clock gating check的两个必要条件，我们就能很容易的分辨出是否需要clock gating check了。&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="STA" /><summary type="html">Clock gating check是一种常见的时序检查，当gating signal控制clock signal时，其跳变必须满足时序要求以得到想要的gated clock。最常见的gating check发生在ICG cell上。ICG是常见的low power解决方案，通过在clock tree上插入ICG cell，来减少ICG后面clock buffer/register的不必要跳变，从而起到降低功耗的目的。其实，只要是多输入逻辑cell，只要满足两个条件，都需要做gating check。</summary></entry><entry><title type="html">hard verification by bad RLT coding style</title><link href="http://localhost:4000/inconclusive-verification-by-bad-rtl-coding-style/" rel="alternate" type="text/html" title="hard verification by bad RLT coding style" /><published>2017-09-15T00:00:00+08:00</published><updated>2017-09-15T00:00:00+08:00</updated><id>http://localhost:4000/inconclusive-verification-by-bad-rtl-coding-style</id><content type="html" xml:base="http://localhost:4000/inconclusive-verification-by-bad-rtl-coding-style/">&lt;p&gt;最近项目中碰到一个hard verification，有11个点inconclusive，属于同一个module下。由于RTL是加密的，无法获知这个module的内容，这也给debug带来了一定麻烦。
&lt;!--more--&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**************************************************
Report         : aborted_points

Reference      : r:/WORK/**
Implementation : i:/WORK/**
Version        : L-2016.03-SP5
Date           : Sat Sep  2 15:44:52 2017
**************************************************

11 Aborted compare points:
       0 Loop  (driven by a potentially state-holding asynchronous loop)
      11 Hard  (too complex to solve)

 Hard :  Ref  DFF        r:/WORK/**/**/**/**/bar1avg4_3d_reg_10_
         Impl DFF        i:/WORK/**/**/**/**/bar1avg4_3d_reg_10_

 Hard :  Ref  DFF        r:/WORK/**/**/**/**/bar1avg4_3d_reg_11_
         Impl DFF        i:/WORK/**/**/**/**/bar1avg4_3d_reg_11_

 Hard :  Ref  DFF        r:/WORK/**/**/**/**/bar1avg4_3d_reg_8_
         Impl DFF        i:/WORK/**/**/**/**/bar1avg4_3d_reg_8_

 Hard :  Ref  DFF        r:/WORK/**/**/**/**/bar1avg4_3d_reg_9_
         Impl DFF        i:/WORK/**/**/**/**/bar1avg4_3d_reg_9_

 Hard :  Ref  DFF        r:/WORK/**/**/**/**/foosum_3d_reg_16___foosum_3d_reg_15___foosum_3d_reg_14___foosum_3d_reg_13___foosum_3d_reg_12___foosum_3d_reg_11___foosum_3d_reg_10___foosum_3d_reg_9_/\*dff.00.0\*
         Impl DFF        i:/WORK/**/**/**/**/foosum_3d_reg_16___foosum_3d_reg_15___foosum_3d_reg_14___foosum_3d_reg_13___foosum_3d_reg_12___foosum_3d_reg_11___foosum_3d_reg_10___foosum_3d_reg_9_/\*dff.00.0\*

 Hard :  Ref  DFF        r:/WORK/**/**/**/**/foosum_3d_reg_16___foosum_3d_reg_15___foosum_3d_reg_14___foosum_3d_reg_13___foosum_3d_reg_12___foosum_3d_reg_11___foosum_3d_reg_10___foosum_3d_reg_9_/\*dff.00.1\*
         Impl DFF        i:/WORK/**/**/**/**/foosum_3d_reg_16___foosum_3d_reg_15___foosum_3d_reg_14___foosum_3d_reg_13___foosum_3d_reg_12___foosum_3d_reg_11___foosum_3d_reg_10___foosum_3d_reg_9_/\*dff.00.1\*
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;debug&quot;&gt;Debug&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;analyze_points&lt;/code&gt;发现都是同一个datapath 被rejected, formality 也给出了建议。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fm_shell (verify)&amp;gt; analyze_points r:/WORK/**/**/**/**/bar1avg4_3d_reg_10_ 
Found 1 Rejected Datapath Guidance Module
--------------------------------
These modules contain cells that may be related to
rejected datapath guidance.
--------------------------------
r:/WORK/**_tdedgdet_M_AVG0_M_TYPE0_0 in file ***/**/**/**.v.e
    Module with rejected datapath guidance on cell(s):
        r:/WORK/**_tdedgdet_M_AVG0_M_TYPE0_0/DP_OP_1054J26_124_1439
     Use 'report_svf_operation { 67437 }' for more information.
     Try adding the following command(s) to your Design Compiler script right before the first compile_ultra command:
          current_design **
          set_verification_priority [ get_cells { **/**/**/add_134952 **/**/**/add_134952_2 **/**/**/add_134952_3 **/**/**/add_134952_4 **/**/**/add_134953 **/**/**/add_134953_2 **/**/**/add_134953_3 **/**/**/add_134953_4 **/**/**/add_134954 **/**/**/add_134954_2 **/**/**/add_134954_3 **/**/**/add_134954_4 **/**/**/add_134955 **/**/**/add_134955_2 **/**/**/add_134955_3 **/**/**/add_134955_4 **/**/**/add_134956 **/**/**/add_134956_10 **/**/**/add_134956_11 **/**/**/add_134956_12 **/**/**/add_134956_13 **/**/**/add_134956_14 **/**/**/add_134956_15 **/**/**/add_134956_2 **/**/**/add_134956_3 **/**/**/add_134956_4 **/**/**/add_134956_5 **/**/**/add_134956_6 **/**/**/add_134956_7 **/**/**/add_134956_8 **/**/**/add_134956_9 **/**/**/add_134961 **/**/**/add_134961_10 **/**/**/add_134961_11 **/**/**/add_134961_12 **/**/**/add_134961_13 **/**/**/add_134961_14 **/**/**/add_134961_15 **/**/**/add_134961_16 **/**/**/add_134961_17 **/**/**/add_134961_18 **/**/**/add_134961_19 **/**/**/add_134961_2 **/**/**/add_134961_20 **/**/**/add_134961_21 **/**/**/add_134961_22 **/**/**/add_134961_23 **/**/**/add_134961_24 **/**/**/add_134961_3 **/**/**/add_134961_4 **/**/**/add_134961_5 **/**/**/add_134961_6 **/**/**/add_134961_7 **/**/**/add_134961_8 **/**/**/add_134961_9 } ]
          
          current_design **

-----------
--------------------------------
****************************************************************************************
Analysis Completed

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看SVF里的67437 operation是什么：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fm_shell (verify)&amp;gt; report_svf_operation { 67437 }
**************************************************
Report         : svf_operation
                 67437 

Reference      : r:/WORK/**
Implementation : i:/WORK/**
Version        : L-2016.03-SP5
Date           : Thu Aug 31 18:27:18 2017
**************************************************

## SVF Operation 67437 (Line: 1926568) - datapath.  Status: rejected
## Operation Id: 67437
guide_datapath \
  -design { **_tdedgdet_M_AVG0_M_TYPE0_0 } \
  -datapath { DP_OP_1054J26_124_1439 } \
  -body { **_tdedgdet_M_AVG0_M_TYPE0_0_DP_OP_1054J26_124_1439_J26_0 } 

Info:  guide_datapath 67437 (Line: 1926568)  Pre-verification of r:/WORK/**_tdedgdet_M_AVG0_M_TYPE0_0/DP_OP_1054J26_124_1439 INCONCLUSIVE.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好像并不能看出太多内容。但是我们可以从formality给的建议里看出，这些cell都是adder。需要注意的是，formality指出的cell name 是在第一次&lt;code&gt;compile_ultra&lt;/code&gt;之前的，也就是说，这些cell name是从RTL转成GTECH网表时的名称。在综合后，这些&lt;code&gt;add_*&lt;/code&gt;module（+操作符）会被打平。&lt;br /&gt;
根据formality提示，在&lt;code&gt;compile_ultra&lt;/code&gt;前加上&lt;code&gt;set_verification_priority&lt;/code&gt;后，这些adder就不会被ungroup，也就不会被打平优化，这样就导致了通过该datapath的timing很差，达到-700ps左右。但是，好处也很明显，通过这样综合的网表，是可以pass formal的。&lt;br /&gt;
DC的DesignWare里有多种adder architecture，综合时，DC会根据design约束自动选择合适的adder&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。当约束不紧时，DC会选择面积小的逐步进位加法器；当约束紧时，DC会选择更快的加法器，比如优化后的超前进位加法器等。我尝试了对u_tdedgdet不给timing constraint，直接compile，得到的网表可以pass formal；又通过&lt;code&gt;characterize&lt;/code&gt;把top constraint约束到u_tdedgdet，综合后，得到的网表为inconclusive。从这里也可以看出，DC对adder的选择和优化过狠，导致hard verification。&lt;br /&gt;
既然加了&lt;code&gt;set_verification_priority&lt;/code&gt;后的网表时序太差，那么能否通过incremental compile来优化timing？&lt;br /&gt;
首先，DC在使用&lt;code&gt;set_verification_priority&lt;/code&gt;时，是将design/cell 的&lt;code&gt;verification_priority&lt;/code&gt; attribute 设为&lt;code&gt;default&lt;/code&gt;,而不是&lt;code&gt;true&lt;/code&gt;，这一点需要注意。&lt;br /&gt;
另外，我发现DC好像无法remove掉该attribute。如下，我明明已经用&lt;code&gt;remove_attribute&lt;/code&gt;或&lt;code&gt;remove_verification_priority&lt;/code&gt;去掉了，而且&lt;code&gt;get_attribute&lt;/code&gt;也显示没有该属性，但是在ungroup、compile的时候还是会有log显示有该属性。这一点真的是比较奇怪，个人觉得应该是DC的一个bug。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
dc_shell&amp;gt; get_cells -filter &quot;verification_priority==default&quot; -hierarchical
{**/**/**/add_x_91 **/**/**/add_x_90 **/**/**/add_x_89 **/**/**/add_x_87 **/**/**/add_x_86 **/**/**/add_x_85 **/**/**/add_x_84 **/**/**/add_x_83 **/**/**/add_x_82 ... }

dc_shell&amp;gt; remove_attribute  [get_cells **/**/**/add_x_*] verification_priority
**/**/**/add_x_91 **/**/**/add_x_90 **/**/**/add_x_89 **/**/**/add_x_87 **/**/**/add_x_86 **/**/**/add_x_85 **/**/**/add_x_84 **/**/**/add_x_83 **/**/**/add_x_82 ...
dc_shell&amp;gt; ungroup [get_cells **/**/**/add_x_*]
Information: '**/**/**/add_x_91' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_90' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_89' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_87' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_86' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_85' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_84' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_83' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_82' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_81' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
...

dc_shell&amp;gt; remove_verification_priority -all
1
dc_shell&amp;gt; ungroup [get_cells **/**/**/add_x_*]
Information: '**/**/**/add_x_91' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_90' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_89' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_87' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_86' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_85' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_84' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_83' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_82' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
Information: '**/**/**/add_x_81' will not be ungrouped because of the verification_priority attribute set on it. (OPT-774)
...

dc_shell&amp;gt; get_attribute **/**/**/add_x_91 verification_priority
Warning: Attribute 'verification_priority' does not exist on cell '**/**/**/add_x_91'. (UID-101)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Anyway，既然不能ungroup，那我就尝试&lt;code&gt;group_path&lt;/code&gt;,把through这些adder的path都拿出来设一个group，优化后发现还是修不下去…这么看来，好像使用&lt;code&gt;verification_priority&lt;/code&gt;这条路进入了死胡同… &lt;br /&gt;
我又试了各种alternative strategy，也仅仅把hard verification points从11个减小到10个… &lt;br /&gt;
换更新的DC/FM版本试试，还是没效果…实在是崩溃… &lt;br /&gt;
最后，向前端要了解密的该module的RTL，结果发现该module里居然12位reg累加了20次，20次！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
reg     [11:0]  foo00_2d, foo01_2d, foo02_2d, foo03_2d, foo04_2d;
reg     [11:0]  foo10_2d, foo11_2d, foo12_2d, foo13_2d, foo14_2d;
reg     [11:0]  foo20_2d, foo21_2d, foo22_2d, foo23_2d, foo24_2d;
reg     [11:0]  foo30_2d, foo31_2d, foo32_2d, foo33_2d, foo34_2d;
reg     [11:0]  foo40_2d, foo41_2d, foo42_2d, foo43_2d, foo44_2d;
//省略部分...
wire    [15:0]  barsum_2d   =	foo00_2d + foo01_2d + foo02_2d + foo03_2d + foo04_2d +
                                foo10_2d +                                + foo14_2d +
                                foo20_2d +                                + foo24_2d +
                                foo30_2d +                                + foo34_2d +
                                foo40_2d + foo41_2d + foo42_2d + foo43_2d + foo44_2d ;
wire    [16:0]  foosum_2d   =	foo00_2d + foo01_2d + foo02_2d + foo03_2d + foo04_2d +
                                foo10_2d + foo11_2d + foo12_2d + foo13_2d + foo14_2d +
                                foo20_2d + foo21_2d + foo22_2d + foo23_2d + foo24_2d +
                                foo30_2d + foo31_2d + foo32_2d + foo33_2d + foo34_2d +
                                foo40_2d + foo41_2d + foo42_2d + foo43_2d + foo44_2d ;
//省略部分...
reg     [14:0]  bar_3d;
reg     [11:0]  bar1avg4_3d;
reg     [16:0]    foosum_3d;
always@(posedge clk)
  if (en&amp;amp;dvd)
  begin
    bar1avg4_3d &amp;lt;= barsum_2d[15:4];
      foosum_3d &amp;lt;=   foosum_2d ;
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以发现，上面这段verilog，由于12位reg多次累加，导致了sum的高位无法pass。而且明显foosum_2d可以复用barsum_2d的逻辑，这部分逻辑是可以优化的。这里复杂的RTL累加，是此次hard verification的罪魁祸首。所以说，good RTL coding style是很重要的，涉及datapath的尤其要注意。SolvNet的&lt;a href=&quot;https://solvnet.synopsys.com/retrieve/015771.html&quot;&gt;Coding Guidelines for Datapath Synthesis&lt;/a&gt;可以好好阅读一下。&lt;br /&gt;
(PS: 文中涉及design相关已做隐藏**)&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://solvnet.synopsys.com/retrieve/018499.html&quot;&gt;DesignWare Adder &amp;amp; Multiplier Characterization&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Leon Sun</name></author><category term="tool" /><category term="verification" /><category term="formality" /><summary type="html">最近项目中碰到一个hard verification，有11个点inconclusive，属于同一个module下。由于RTL是加密的，无法获知这个module的内容，这也给debug带来了一定麻烦。</summary></entry><entry><title type="html">Control NDM unexpected pin shapes</title><link href="http://localhost:4000/control-ndm-unexpected-pin-shapes/" rel="alternate" type="text/html" title="Control NDM unexpected pin shapes" /><published>2017-08-31T00:00:00+08:00</published><updated>2017-08-31T00:00:00+08:00</updated><id>http://localhost:4000/control-ndm-unexpected-pin-shapes</id><content type="html" xml:base="http://localhost:4000/control-ndm-unexpected-pin-shapes/">&lt;p&gt;从ICC2开始, synopsys 为了提高PR工具的速度，引入了一种新格式的库，即NDM(new data model)。NDM 其实就是将logic info 和 physical info合成到一起，NDM有4种view:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;layout view&lt;/li&gt;
  &lt;li&gt;design view&lt;/li&gt;
  &lt;li&gt;frame view&lt;/li&gt;
  &lt;li&gt;timing view&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用ICC2 library manger 生成NDM时，physical lib 是必须的，可以为lef、gds、oasis、ICC frame，常用的是lef/gds。使用lef时，比较方便，因为lef里含有design info，如site name，cell type，pin direction 等信息（site name有时会需要转成与tech lef一致，&lt;code&gt;read_lef -convert_sites&lt;/code&gt;）；而使用gds/oasis时，就比较麻烦，这是因为，gds里只有一层层的metal，site name/cell type 这些信息需要用户根据实际指定（marco,pad,corner,filler,cover…), pin name可以从通过trace text得到，而pin direction 则必须从timing lib得到。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;碰到的问题是，使用gds作为physical source来产生NDM时，会将每个via cut shape当做termial。&lt;br /&gt;
gds 局部图如下，text 在每层metal上，每层metal之间有width 0.05um spacing 0.08um 的via。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017-08-31_gds.png&quot; alt=&quot;gds局部图&quot; width=&quot;70%&quot; /&gt; &lt;br /&gt;
extract frame时设了&lt;code&gt;lib.physical_model.merge_metal_blockage&lt;/code&gt;为true，根据man page，当两块metal之间距离小于spacing threshold (2&lt;em&gt;min_spacing-min_width)时会被merge，查看techfile，该层min witdh和min spacing分别为0.05和0.08，那么threshold应该为2&lt;/em&gt;0.08-0.05=0.11。而这些via之间间距为0.08，却没有被merge。
这会有什么影响呢？PR时，ICC2里会报如下warning:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Warning: Cell **** port DVSS09 contains more than 1000000 pins (Number of pins: 1062350).  This may increase routing runtime. (ZRT-565)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个warning的意思应该是含有太多的pin shape，或者说这个port 有太多的terminal。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;icc2_shell&amp;gt; sizeof_collection [get_shapes -of [get_ports DVSS09*]]
1059159
icc2_shell&amp;gt; sizeof_collection [get_terminals DVSS09*]
1059159
icc2_shell&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该warning的manpage如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
ZRT-565  
  
NAME  
  
ZRT-565 (warning) Cell %s port %s contains more than %d pins (Number of pins: %d). This may increase routing runtime.  
  
DESCRIPTION  
  
A port contains a large number of pins. This is atypical and may increase routing runtime.  
  
WHAT NEXT  
  
If this is not expected, please reduce the number of pins for the port.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;read_gds -trace_option&lt;/code&gt;：尝试改变gds trace option，&lt;code&gt;pins_only&lt;/code&gt;,&lt;code&gt;same_layer&lt;/code&gt;都没有效果；&lt;br /&gt;
2.&lt;code&gt;read_gds -trace_connectivity_limit&lt;/code&gt;: 尝试设trace limit 为1，仍然没有效果；&lt;br /&gt;
3.&lt;code&gt;file.gds.create_custom_via&lt;/code&gt;:尝试把那些via cut shape当做一整个via，这个变量设为true，runtime大大增加，未等待到结果；&lt;br /&gt;
4.&lt;code&gt;file.gds.exclude_layers&lt;/code&gt;: 直接把gds里的via layer都exclude。  &lt;br /&gt;
在&lt;code&gt;read_gds&lt;/code&gt;前，&lt;code&gt;set_app_options -name file.gds.exclude_layers -value { {VIA1 VIA1} {VIA2 VIA2} {VIA3 VIA3} {VIA4 VIA4} {VIA5 VIA5} {VIA6 VIA6} {VIA7 VIA7} }&lt;/code&gt;，让lm忽略所有via layer，果然生成的NDM里没有了那些pin shape。这些via的enclosure没有超出upper/lower metal，所有去掉这些via在route时应该不会引起额外的drc。&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;使用GDS作为physical source生成NDM时，design info需要tool自己trace，这个过程有许多变量来控制，要根据实际需要调整这些变量来得到合理的NDM。&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="tool" /><category term="icc2_lm" /><category term="ndm" /><summary type="html">从ICC2开始, synopsys 为了提高PR工具的速度，引入了一种新格式的库，即NDM(new data model)。NDM 其实就是将logic info 和 physical info合成到一起，NDM有4种view: layout view design view frame view timing view 使用ICC2 library manger 生成NDM时，physical lib 是必须的，可以为lef、gds、oasis、ICC frame，常用的是lef/gds。使用lef时，比较方便，因为lef里含有design info，如site name，cell type，pin direction 等信息（site name有时会需要转成与tech lef一致，read_lef -convert_sites）；而使用gds/oasis时，就比较麻烦，这是因为，gds里只有一层层的metal，site name/cell type 这些信息需要用户根据实际指定（marco,pad,corner,filler,cover…), pin name可以从通过trace text得到，而pin direction 则必须从timing lib得到。</summary></entry><entry><title type="html">How to pass formal check</title><link href="http://localhost:4000/how-to-pass-formal-check/" rel="alternate" type="text/html" title="How to pass formal check" /><published>2017-08-23T00:00:00+08:00</published><updated>2017-08-23T00:00:00+08:00</updated><id>http://localhost:4000/how-to-pass-formal-check</id><content type="html" xml:base="http://localhost:4000/how-to-pass-formal-check/">&lt;h2 id=&quot;formality&quot;&gt;Formality&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Formality® is an equivalence-checking (EC) solution that uses formal, static techniques to determine if two versions of a design are functionally equivalent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Formality是Synopsys家的LEC工具，是IC设计中常用的工具之一。后端设计中，一般要做两次formality check:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;综合后，RTL VS synthesis gate-level netlist.&lt;/li&gt;
  &lt;li&gt;PR后，synthesis netlist VS PR netlist.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017-08-21_111804.png&quot; alt=&quot;formality check in physical design&quot; title=&quot;formality check in physical design&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DC综合时，涉及designware mapping, retiming optimize, regisiter add/removal等复杂的逻辑操作，导致RLT-gate formality check会比较棘手，虽然DC会产生SVF( Setup Verification for Formality),但是由于设计复杂性，仍然会产生各种意想不到的fail/hard verification.
PR中，由于涉及到的逻辑优化较简单，一般不难pass formality;如果涉及复杂优化，如add/spilt multibit bank等复杂逻辑操作，也许需要生成svf来辅助formality check.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SVF:
 Setup Verification for Formality, 记录优化过程中的各项逻辑操作，比如replace, merge, uniquify, retime, reg_constant等等，是用于辅助formality verification的。DC产生的不可读svf可以在formality内转成可读文本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;rtl-vs-gate&quot;&gt;RTL VS GATE&lt;/h2&gt;
&lt;p&gt;如果综合后，RTL-Gate formality fail/inconclusive,该如何debug呢？
Formality debug 可以有logic cone, failing pattern, analyze_point, alternative strategy 等。&lt;/p&gt;
&lt;h3 id=&quot;fail&quot;&gt;Fail&lt;/h3&gt;
&lt;p&gt;Formality fail 通常有以下几种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;miss constraint
 这种情况下，一般容易从pattern里发现。如果failing pattern里某个pin的值都是相同的，比如failing point 的input pin SE 都是1，则很可能是由于做function formality时 scan enable port 没有设为constant value.&lt;/li&gt;
  &lt;li&gt;datapath
 这里的datapath不是指STA里的data/clk path, 而是加减乘除之内的逻辑运算。这些逻辑 运算可以自己rtl实现，也可以直接例化S家的designware。对于同一个逻辑运算，比如3位乘以5位的乘法器，底层实现可能有多种方式。为了实现timing, S家的大部分designware,如div/multi/div_pipe/multi_pipe等都内置retime属性，在compile时会根据design来做retime 优化。前面也说过，retime属于复杂操作，容易引起fail verification.
主要的处理办法有以下几种：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;DC里对整个design 设置&lt;code&gt;simplified_verification_mode&lt;/code&gt;，其实就是设置下面的参数:
    &lt;blockquote&gt;
      &lt;p&gt;The tool sets the value for the following  environment  variables  when the  simplified_verification_mode variable is set to true regardless of the value you specify:&lt;/p&gt;

      &lt;p&gt;compile_ultra_ungroup_dw = false&lt;/p&gt;

      &lt;p&gt;compile_clock_gating_through_hierarchy = false&lt;/p&gt;

      &lt;p&gt;hdlin_verification_priority = true&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;在DC里使用&lt;code&gt;set_verification_priority&lt;/code&gt; 来告诉DC某个cell/design，要verification优先，不要优化地太狠，不要ungroup。但是verification_priority attribute不会传到subdesign.&lt;/li&gt;
  &lt;li&gt;分两步综合，首先对相关design设dont_retime，compile后,再对design 用optimize_register 做Retime 优化。&lt;/li&gt;
  &lt;li&gt;前面的法都是goabl方法，虽然简单，但是个人发现通常效果并不好,这样的话就要具体问题具分析。
利用&lt;code&gt;analyze_points&lt;/code&gt; 对failing point分析，通常formality会给出fail reason 和recommendtion. Fail reason 通常会是某些相关的svf operation 被formality rejected.常见的有guide_reg_constant,guide_replace，guide_change_name之类。然后可以用&lt;code&gt;report_svf_operation -command * -status rejected&lt;/code&gt; 来查看具体是为啥这个svf operation 被formality rejected。比如经常出现的是formality找不到某些pin/cell,这时候就要确认原因，是因为name mismatch 还是真的不存在，不存在的情况多为DC默认会把redundant cell/constant register 删除掉，也许它是为了area考虑，结果导致了formality fail。确定起因后，就要在DC 里work-around 来避免这个问题发生。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inconclusive&quot;&gt;Inconclusive&lt;/h3&gt;

&lt;p&gt;Inconclusive 一般由于逻辑太复杂，logic cone 太大，导致formality长时间比较后仍然得不出结论。一般解决方法有:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;换更新的formality版本，花钱消灾…&lt;/li&gt;
  &lt;li&gt;加大timeout limit: &lt;code&gt;verification_timeout_limit&lt;/code&gt;, 0 为no limit;&lt;/li&gt;
  &lt;li&gt;设高datapath effort：&lt;code&gt;verification_datapath_effort_level&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;使用alternate strategy：formality内置其它多种不同算法来比较hard verification,需要挨个尝试，可能全部试过多没用，自求多福…
    &lt;blockquote&gt;
      &lt;p&gt;verification_alternate_strategy specifies that verification uses a nonstandard strategy for solving hard verifications.&lt;/p&gt;

      &lt;p&gt;The order of the list indicates which strategy to use first:&lt;/p&gt;

      &lt;p&gt;none s2 s3 s1 l2 s10 s8 l1 l3 s4 s6 s5 k1 k2 s7 s9&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;DC里相关design设置verification优先，降低opt effort；&lt;/li&gt;
  &lt;li&gt;DC先compile hard_verification design, 再compile other designs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;project-cases&quot;&gt;Project Cases&lt;/h2&gt;
&lt;h3 id=&quot;case-1&quot;&gt;Case 1&lt;/h3&gt;
&lt;h4 id=&quot;11-problem&quot;&gt;1.1 Problem&lt;/h4&gt;
&lt;p&gt;综合后，formality fail，有73个failing points，这些points都属于两个module，随便选取一个points:
u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1
其余failing points的命名也类似，从这些reg的名字可以看出它们都是做了retime优化的（DC retime的默认命名**REG**_S*).这些reg都是U_DIV module下，而这个U_DIV是例化了一个DW_div_pipe designware.&lt;/p&gt;
&lt;h4 id=&quot;12-debug&quot;&gt;1.2 Debug&lt;/h4&gt;
&lt;p&gt;打开logic cone， 如下图,发现failing points是SD/AD, 在Imp里是constant0; 而Ref里它们是从fm_bb出来，fm_bb 是formality black box，bbox 的input被formality认为loginc cone 的endpoint, output 被认为是logic cone的startpoint,因为不知内部逻辑，其output作为logic cone的startpoint时可以为0/1/X。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/logic_cone.png&quot; alt=&quot;logic cone&quot; title=&quot;logic cone&quot; /&gt;&lt;/p&gt;

&lt;p&gt;analyze_points 对这个点分析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fm_shell (verify)&amp;gt; analyze_points r:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1
Found 2 Unmatched Cone Inputs
--------------------------------
Unmatched cone inputs result either from mismatched compare points
or from differences in the logic within the cones. Only unmatched
inputs that are suspected of contributing to verification failures
are included in the report.
The source of the matching or logical differences may be determined
using the schematic, cone and source views.
--------------------------------
r:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/clk_gate_a_int_reg[1]/latch/\*lat.00\*
    Is globally unmatched affecting 1 compare point(s):
        i:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1

-----------
r:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/fm_bb/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/a_int_reg[3][0]
    Matched with pin i:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/fm_bb/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/a_int_reg[3][0]
    Exists in the ref cone but not in the impl cone for 1 compare point(s):
        i:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1

-----------
--------------------------------
Found 1 Rejected Guidance Command
--------------------------------
The rejection of some SVF guidance commands will almost invariably
cause verification failures. For more information use:
        report_svf_operation -status rejected -command command_name
--------------------------------
reg_constant
-----------
--------------------------------
****************************************************************************************
Analysis Completed
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析report,首先logic cone 有两个unmatched inputs：一个是gating, 但是发现这个gating并不影响func,而且ref/imp reg的CK 都是r,所以这个gating并不是导致failing points的原因；另一个是fm_bb，这个存在于ref里，也正是由于这个fm_bb的output是1才导致SD/AD pin fail。
接着，有一个guidance cmd 被rejected：guide_reg_constant，这是svf里把reg标为constant 0/1 的操作。联想到imp里SD/AD pin的startpoints 都是constant 0, 所以应该是DC做reg_constant 操作，将failing point 前的reg 标为0，但是这个操作因为某种原因被formality rejected, 从而ref 里引入了fm_bb。那么到底是为何被reject? report_svf_operation report 截取一段如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## SVF Operation 945483 (Line: 8463522) - reg_constant.  Status: rejected
## Operation Id: 945483
guide_reg_constant \
  -design { wp45 } \
  -replaced { svfTrue } \
  { u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1 } \
  { 0 } 

Info:  guide_reg_constant 945483 (Line: 8463522) Cannot find master reference cell 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1'.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因就是：&lt;strong&gt;cannot find master reference cell&lt;/strong&gt;。居然没有这个cell?那它又是哪来的？查找svf file，发现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## Operation Id: 875794
guide_retiming \
  -design { wp45 } \
  -direction { forward } \
  -libCell { FM_FORK } \
  -input { :__tmp__name___1392479 } \
  -output { :u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1 } 

## Operation Id: 945483
guide_reg_constant \
  -design { wp45 } \
  -replaced { svfTrue } \
  { u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1 } \
  { 0 } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个reg是经过forward retime后命名为此，随后DC觉得它是个constant 0 reg。constant0 reg可能是因为D pin tie 0,也可能是reset pin tie 1 导致的。那么DC是怎么处理这些constant register 的呢？查找DC log,发现如下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm2/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm1/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm0/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;真相大白：&lt;strong&gt;默认情况下，DC会remove constant register, 并在log里给出OPT-1206提示&lt;/strong&gt;。至此，终于找到failing root cause,下面就是针对问题找到解决方法了。DC 对constant register 的处理由以下3个变量控制，默认值都是true:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile_seqmap_propagate_constants:           Removes cells with a constant on the input.
compile_seqmap_propagate_high_effort:         Removes cells with a constant on the reset.
compile_seqmap_propagate_constants_size_only: Propagates constants through size_only cells.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;compile_seqmap_propagate_constants_size_only&lt;/code&gt; 是控制是否传递size_only/dont_touch attribute的constant reg 的constant value，而不是要remove size_only/dont_touch reg。
所以，我们在compile前将这些变量设为false,问题应该就可以迎刃而解了吧。尝试之后，万万没想到，failing points居然更多，而且有很多&lt;code&gt;Required Inputs&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--------------------------------
Found 61 Required Inputs
--------------------------------
A required input is one that is designated as required
for all failing patterns for one or more cpoints and fans out 
to more failing than passing points.
This implies that it may be driving downstream logic that is related to
the failure(s)
--------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此看来，这个变量好像不能乱设啊。不清楚为啥不remove const reg，会导致这么严重的问题。之前的debug好像都付诸东流了…&lt;/p&gt;

&lt;h4 id=&quot;13-slove&quot;&gt;1.3 Slove&lt;/h4&gt;
&lt;p&gt;既然这些reg 是例化了的DW_div_pipe内部的，然后经retime命名为此；那么为何FM retime的时候不能找到它了？难道是FM 的retime 与DC的retime有什么不一样了？明明已经读了SVF，FM会根据SVF做retime呀，真是越想越不合理… &lt;br /&gt;
换个更新版本的DC/FM尝试一下吧，结果居然pass了！！！:disappointed_relieved: &lt;br /&gt;
所以，&lt;strong&gt;如果failing points不多，而且都与DesignWare相关，那么请首先尝试更新版本！&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;case2&quot;&gt;Case2&lt;/h3&gt;
&lt;h4 id=&quot;21-problem&quot;&gt;2.1 Problem&lt;/h4&gt;
&lt;p&gt;综合完，RTL-Gate Formality inconclusive, 有33个points。原来这个module属于一个42bit除以9bit的除法器，每一位quotient的logic cone都很大，formality 很难比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
********************************* Verification Results *********************************
Verification INCONCLUSIVE
(Equivalence checking aborted due to complexity)
   ATTENTION: synopsys_auto_setup mode was enabled.
              See Synopsys Auto Setup Summary for details.
   ATTENTION: RTL interpretation messages were produced during link
              of reference design.
              Verification results may disagree with a logic simulator.
-----------------------------------------------------------------------
 Reference design: r:/WORK/***
 Implementation design: i:/WORK/***
 161129 Passing compare points
 33 Aborted compare points
 0 Unverified compare points
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;22-debug&quot;&gt;2.2 Debug&lt;/h4&gt;
&lt;p&gt;前文提到的方法我都一一试过:timeout-limit, datapath-effort, new tool version, set_verification_priority, 10多种alternative strategy 都没用……
难道真的是因为这个42bit/9bit 的除法器太大了，无论如何都无法过formality?
那么仅综合这个除法器能不能过呢？我尝试把这个除法器module摘出来，仅综合这个module，然后对这个module做formal check,奇迹出现了，居然SUCCESSED.&lt;/p&gt;
&lt;h4 id=&quot;23-solve&quot;&gt;2.3 Solve&lt;/h4&gt;
&lt;p&gt;最终，通过优先综合除法器design，再综合其它design, 才成功pass formal check.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;RTL-Gate LEC check 是一项很复杂的过程，通常需要在DC/formality里迭代完成，这是非常耗时的，所以formal check 的经验在此格外重要，大牛可能一眼就看出是什么原因，需要在综合时做何种设置；而吾类菜鸟就要慢慢debug,花费大量时间尝试各种可能。文中所述仅为本人在项目中积累的粗浅经验，有错请指正。&lt;strong&gt;不积跬步无以至千里&lt;/strong&gt;，不断积累，早日成大牛!&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="tool" /><category term="formality" /><category term="verification" /><summary type="html">Formality Formality® is an equivalence-checking (EC) solution that uses formal, static techniques to determine if two versions of a design are functionally equivalent.</summary></entry><entry><title type="html">Hello World</title><link href="http://localhost:4000/Hello-World/" rel="alternate" type="text/html" title="Hello World" /><published>2017-07-26T00:00:00+08:00</published><updated>2017-07-26T00:00:00+08:00</updated><id>http://localhost:4000/Hello-World</id><content type="html" xml:base="http://localhost:4000/Hello-World/">&lt;p&gt;第0篇blog,当然是献给&lt;code&gt;Hello World&lt;/code&gt;.
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id=&quot;为何写blog&quot;&gt;为何写blog?&lt;/h2&gt;
&lt;h3 id=&quot;1-更深刻地思考&quot;&gt;1. 更深刻地思考&lt;/h3&gt;
&lt;p&gt;写blog，是一次真正的思考过程。因为要写出来，所以你要有清晰的条理，合理的逻辑。当你在写作时，会深究前因后果，会比平时思考的更加深刻，更能提高你的逻辑思维能力。&lt;/p&gt;
&lt;h3 id=&quot;2-更深入地理解&quot;&gt;2. 更深入地理解&lt;/h3&gt;
&lt;p&gt;真正的理解，不是自己明白，而是能让别人明白。在别人请教你问题时，你也许会发现其实你的理解并不全面或并不正确；你给别人讲解的过程，也是你自己反思的过程，这个过程里你可能会有意外收获。写blog，这是一个像陌生人讲解的过程，如果他人能够认可你的解释，那才说明你真正地理解了。&lt;/p&gt;
&lt;h3 id=&quot;3-更持续地学习&quot;&gt;3. 更持续地学习&lt;/h3&gt;
&lt;p&gt;做技术相关的工作，怎么能不持续学习？信息时代，技术迭代更新的速度大大加快。不断地学习新知识和新技术是提高自身竞争的不二法门。&lt;/p&gt;
&lt;h3 id=&quot;4-更具体的记忆&quot;&gt;4. 更具体的记忆&lt;/h3&gt;
&lt;p&gt;只有大牛才能写blog? NO！不要害怕出错，这是个提高的过程。多年后，你可以从你的blog上看到你的成长，blog里记录了你菜鸟时期的傻逼问题，也记录了你成长之后的深邃理解，这就是你自己的记忆。&lt;/p&gt;

&lt;h2 id=&quot;写什么&quot;&gt;写什么？&lt;/h2&gt;
&lt;h3 id=&quot;1-工作相关的技术问题&quot;&gt;1. 工作相关的技术问题&lt;/h3&gt;
&lt;p&gt;主要记录、总结、反思工作/学习过程中碰到的相关技术问题。IC phyical design 是个复杂的过程，工作过程中碰到的知识点有很多很杂。&lt;/p&gt;
&lt;h3 id=&quot;2-其它方面的兴趣爱好&quot;&gt;2. 其它方面的兴趣爱好&lt;/h3&gt;
&lt;p&gt;类似于学习笔记吧，可能会包括java,python等，&lt;/p&gt;
&lt;h3 id=&quot;3-生活吐槽&quot;&gt;3. 生活吐槽？&lt;/h3&gt;
&lt;p&gt;貌似github page不能加password protect，待定。&lt;/p&gt;

&lt;h2 id=&quot;怎么写&quot;&gt;怎么写？&lt;/h2&gt;
&lt;p&gt;就是github + jekyll 搭个自己的blog了。用markdown 写blog，github pg 编译成静态网页，还能免费托管在github，完美。&lt;br /&gt;
jekyll 基于ruby, 配合github page使用过程中还是有很多坑的，还好大多数都已经有前人替我们趟过，然后无私地写blog分享出来，share！&lt;br /&gt;
看着自己的blog从一无所有，到navigation、footer、theme、code hlighlight，再到disqus comment,google analytics，还有不断地调整css 达到自己想要的效果，真的是很有成就感啊:smile:&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;我就是自己的读者，即使是唯一的，我也会keep writing…&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="杂谈" /><summary type="html">第0篇blog,当然是献给Hello World.</summary></entry></feed>
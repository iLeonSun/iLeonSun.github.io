<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2017-09-04T18:05:51+08:00</updated><id>http://localhost:4000/</id><title type="html">Leon Sun</title><subtitle>Blog and website of Leon Sun</subtitle><author><name>Leon Sun</name></author><entry><title type="html">Control NDM unexpected pin shapes</title><link href="http://localhost:4000/control-ndm-unexpected-pin-shapes/" rel="alternate" type="text/html" title="Control NDM unexpected pin shapes" /><published>2017-08-31T00:00:00+08:00</published><updated>2017-08-31T00:00:00+08:00</updated><id>http://localhost:4000/control-ndm-unexpected-pin-shapes</id><content type="html" xml:base="http://localhost:4000/control-ndm-unexpected-pin-shapes/">&lt;p&gt;从ICC2开始, synopsys 为了提高PR工具的速度，引入了一种新格式的库，即NDM(new data model)。NDM 其实就是将logic info 和 physical info合成到一起，NDM有4种view:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;layout view&lt;/li&gt;
  &lt;li&gt;design view&lt;/li&gt;
  &lt;li&gt;frame view&lt;/li&gt;
  &lt;li&gt;timing view&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用ICC2 library manger 生成NDM时，physical lib 是必须的，可以为lef、gds、oasis、ICC frame，常用的是lef/gds。使用lef时，比较方便，因为lef里含有design info，如site name，cell type，pin direction 等信息（site name有时会需要转成与tech lef一致，&lt;code&gt;read_lef -convert_sites&lt;/code&gt;）；而使用gds/oasis时，就比较麻烦，这是因为，gds里只有一层层的metal，site name/cell type 这些信息需要用户根据实际指定（marco,pad,corner,filler,cover…), pin name可以从通过trace text得到，而pin direction 则必须从timing lib得到。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;碰到的问题是，使用gds作为physical source来产生NDM时，会将每个via cut shape当做termial。&lt;br /&gt;
gds 局部图如下，text 在每层metal上，每层metal之间有width 0.05um spacing 0.08um 的via。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017-08-31_gds.png&quot; alt=&quot;gds局部图&quot; width=&quot;70%&quot; /&gt; &lt;br /&gt;
extract frame时设了&lt;code&gt;lib.physical_model.merge_metal_blockage&lt;/code&gt;为true，根据man page，当两块metal之间距离小于spacing threshold (2&lt;em&gt;min_spacing-min_width)时会被merge，查看techfile，该层min witdh和min spacing分别为0.05和0.08，那么threshold应该为2&lt;/em&gt;0.08-0.05=0.11。而这些via之间间距为0.08，却没有被merge。
这会有什么影响呢？PR时，ICC2里会报如下warning:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Warning: Cell **** port DVSS09 contains more than 1000000 pins (Number of pins: 1062350).  This may increase routing runtime. (ZRT-565)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个warning的意思应该是含有太多的pin shape，或者说这个port 有太多的terminal。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;icc2_shell&amp;gt; sizeof_collection [get_shapes -of [get_ports DVSS09*]]
1059159
icc2_shell&amp;gt; sizeof_collection [get_terminals DVSS09*]
1059159
icc2_shell&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该warning的manpage如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZRT-565  
  
NAME  
  
ZRT-565 (warning) Cell %s port %s contains more than %d pins (Number of pins: %d). This may increase routing runtime.  
  
DESCRIPTION  
  
A port contains a large number of pins. This is atypical and may increase routing runtime.  
  
WHAT NEXT  
  
If this is not expected, please reduce the number of pins for the port.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;read_gds -trace_option&lt;/code&gt;：尝试改变gds trace option，&lt;code&gt;pins_only&lt;/code&gt;,&lt;code&gt;same_layer&lt;/code&gt;都没有效果；&lt;br /&gt;
2.&lt;code&gt;read_gds -trace_connectivity_limit&lt;/code&gt;: 尝试设trace limit 为1，仍然没有效果；&lt;br /&gt;
3.&lt;code&gt;file.gds.create_custom_via&lt;/code&gt;:尝试把那些via cut shape当做一整个via，这个变量设为true，runtime大大增加，未等待到结果；&lt;br /&gt;
4.&lt;code&gt;file.gds.exclude_layers&lt;/code&gt;: 直接把gds里的via layer都exclude。  &lt;br /&gt;
在&lt;code&gt;read_gds&lt;/code&gt;前，&lt;code&gt;set_app_options -name file.gds.exclude_layers -value { {VIA1 VIA1} {VIA2 VIA2} {VIA3 VIA3} {VIA4 VIA4} {VIA5 VIA5} {VIA6 VIA6} {VIA7 VIA7} }&lt;/code&gt;，让lm忽略所有via layer，果然生成的NDM里没有了那些pin shape。这些via的enclosure没有超出upper/lower metal，所有去掉这些via在route时应该不会引起额外的drc。&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;使用GDS作为physical source生成NDM时，design info需要tool自己trace，这个过程有许多变量来控制，要根据实际需要调整这些变量来得到合理的NDM。&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="tool" /><category term="icc2_lm" /><category term="ndm" /><summary type="html">从ICC2开始, synopsys 为了提高PR工具的速度，引入了一种新格式的库，即NDM(new data model)。NDM 其实就是将logic info 和 physical info合成到一起，NDM有4种view: layout view design view frame view timing view 使用ICC2 library manger 生成NDM时，physical lib 是必须的，可以为lef、gds、oasis、ICC frame，常用的是lef/gds。使用lef时，比较方便，因为lef里含有design info，如site name，cell type，pin direction 等信息（site name有时会需要转成与tech lef一致，read_lef -convert_sites）；而使用gds/oasis时，就比较麻烦，这是因为，gds里只有一层层的metal，site name/cell type 这些信息需要用户根据实际指定（marco,pad,corner,filler,cover…), pin name可以从通过trace text得到，而pin direction 则必须从timing lib得到。</summary></entry><entry><title type="html">How to pass formal check</title><link href="http://localhost:4000/how-to-pass-formal-check/" rel="alternate" type="text/html" title="How to pass formal check" /><published>2017-08-23T00:00:00+08:00</published><updated>2017-08-23T00:00:00+08:00</updated><id>http://localhost:4000/how-to-pass-formal-check</id><content type="html" xml:base="http://localhost:4000/how-to-pass-formal-check/">&lt;h2 id=&quot;formality&quot;&gt;Formality&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Formality® is an equivalence-checking (EC) solution that uses formal, static techniques to determine if two versions of a design are functionally equivalent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Formality是Synopsys家的LEC工具，是IC设计中常用的工具之一。后端设计中，一般要做两次formality check:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;综合后，RTL VS synthesis gate-level netlist.&lt;/li&gt;
  &lt;li&gt;PR后，synthesis netlist VS PR netlist.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/2017-08-21_111804.png&quot; alt=&quot;formality check in physical design&quot; title=&quot;formality check in physical design&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DC综合时，涉及designware mapping, retiming optimize, regisiter add/removal等复杂的逻辑操作，导致RLT-gate formality check会比较棘手，虽然DC会产生SVF( Setup Verification for Formality),但是由于设计复杂性，仍然会产生各种意想不到的fail/hard verification.
PR中，由于涉及到的逻辑优化较简单，一般不难pass formality;如果涉及复杂优化，如add/spilt multibit bank等复杂逻辑操作，也许需要生成svf来辅助formality check.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SVF:
 Setup Verification for Formality, 记录优化过程中的各项逻辑操作，比如replace, merge, uniquify, retime, reg_constant等等，是用于辅助formality verification的。DC产生的不可读svf可以在formality内转成可读文本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;rtl-vs-gate&quot;&gt;RTL VS GATE&lt;/h2&gt;
&lt;p&gt;如果综合后，RTL-Gate formality fail/inconclusive,该如何debug呢？
Formality debug 可以有logic cone, failing pattern, analyze_point, alternative strategy 等。&lt;/p&gt;
&lt;h3 id=&quot;fail&quot;&gt;Fail&lt;/h3&gt;
&lt;p&gt;Formality fail 通常有以下几种情况：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;miss constraint
 这种情况下，一般容易从pattern里发现。如果failing pattern里某个pin的值都是相同的，比如failing point 的input pin SE 都是1，则很可能是由于做function formality时 scan enable port 没有设为constant value.&lt;/li&gt;
  &lt;li&gt;datapath
 这里的datapath不是指STA里的data/clk path, 而是加减乘除之内的逻辑运算。这些逻辑 运算可以自己rtl实现，也可以直接例化S家的designware。对于同一个逻辑运算，比如3位乘以5位的乘法器，底层实现可能有多种方式。为了实现timing, S家的大部分designware,如div/multi/div_pipe/multi_pipe等都内置retime属性，在compile时会根据design来做retime 优化。前面也说过，retime属于复杂操作，容易引起fail verification.
主要的处理办法有以下几种：&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;DC里对整个design 设置&lt;code&gt;simplified_verification_mode&lt;/code&gt;，其实就是设置下面的参数:
    &lt;blockquote&gt;
      &lt;p&gt;The tool sets the value for the following  environment  variables  when the  simplified_verification_mode variable is set to true regardless of the value you specify:&lt;/p&gt;

      &lt;p&gt;compile_ultra_ungroup_dw = false&lt;/p&gt;

      &lt;p&gt;compile_clock_gating_through_hierarchy = false&lt;/p&gt;

      &lt;p&gt;hdlin_verification_priority = true&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;在DC里使用&lt;code&gt;set_verification_priority&lt;/code&gt; 来告诉DC某个cell/design，要verification优先，不要优化地太狠，不要ungroup。但是verification_priority attribute不会传到subdesign.&lt;/li&gt;
  &lt;li&gt;分两步综合，首先对相关design设dont_retime，compile后,再对design 用optimize_register 做Retime 优化。&lt;/li&gt;
  &lt;li&gt;前面的法都是goabl方法，虽然简单，但是个人发现通常效果并不好,这样的话就要具体问题具分析。
利用&lt;code&gt;analyze_points&lt;/code&gt; 对failing point分析，通常formality会给出fail reason 和recommendtion. Fail reason 通常会是某些相关的svf operation 被formality rejected.常见的有guide_reg_constant,guide_replace，guide_change_name之类。然后可以用&lt;code&gt;report_svf_operation -command * -status rejected&lt;/code&gt; 来查看具体是为啥这个svf operation 被formality rejected。比如经常出现的是formality找不到某些pin/cell,这时候就要确认原因，是因为name mismatch 还是真的不存在，不存在的情况多为DC默认会把redundant cell/constant register 删除掉，也许它是为了area考虑，结果导致了formality fail。确定起因后，就要在DC 里work-around 来避免这个问题发生。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;inconclusive&quot;&gt;Inconclusive&lt;/h3&gt;

&lt;p&gt;Inconclusive 一般由于逻辑太复杂，logic cone 太大，导致formality长时间比较后仍然得不出结论。一般解决方法有:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;换更新的formality版本，花钱消灾…&lt;/li&gt;
  &lt;li&gt;加大timeout limit: &lt;code&gt;verification_timeout_limit&lt;/code&gt;, 0 为no limit;&lt;/li&gt;
  &lt;li&gt;设高datapath effort：&lt;code&gt;verification_datapath_effort_level&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;使用alternate strategy：formality内置其它多种不同算法来比较hard verification,需要挨个尝试，可能全部试过多没用，自求多福…
    &lt;blockquote&gt;
      &lt;p&gt;verification_alternate_strategy specifies that verification uses a nonstandard strategy for solving hard verifications.&lt;/p&gt;

      &lt;p&gt;The order of the list indicates which strategy to use first:&lt;/p&gt;

      &lt;p&gt;none s2 s3 s1 l2 s10 s8 l1 l3 s4 s6 s5 k1 k2 s7 s9&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;DC里相关design设置verification优先，降低opt effort；&lt;/li&gt;
  &lt;li&gt;DC先compile hard_verification design, 再compile other designs.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;project-cases&quot;&gt;Project Cases&lt;/h2&gt;
&lt;h3 id=&quot;case-1&quot;&gt;Case 1&lt;/h3&gt;
&lt;h4 id=&quot;11-problem&quot;&gt;1.1 Problem&lt;/h4&gt;
&lt;p&gt;综合后，formality fail，有73个failing points，这些points都属于两个module，随便选取一个points:
u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1
其余failing points的命名也类似，从这些reg的名字可以看出它们都是做了retime优化的（DC retime的默认命名**REG**_S*).&lt;/p&gt;
&lt;h4 id=&quot;12-debug&quot;&gt;1.2 Debug&lt;/h4&gt;
&lt;p&gt;打开logic cone， 如下图,发现failing points是SD/AD, 在Imp里是constant0; 而Ref里它们是从fm_bb出来，fm_bb 是formality black box，bbox 的input被formality认为loginc cone 的endpoint, output 被认为是logic cone的startpoint,因为不知内部逻辑，其output作为logic cone的startpoint时可以为0/1/X。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/logic_cone.png&quot; alt=&quot;logic cone&quot; title=&quot;logic cone&quot; /&gt;&lt;/p&gt;

&lt;p&gt;analyze_points 对这个点分析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fm_shell (verify)&amp;gt; analyze_points r:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1
Found 2 Unmatched Cone Inputs
--------------------------------
Unmatched cone inputs result either from mismatched compare points
or from differences in the logic within the cones. Only unmatched
inputs that are suspected of contributing to verification failures
are included in the report.
The source of the matching or logical differences may be determined
using the schematic, cone and source views.
--------------------------------
r:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/clk_gate_a_int_reg[1]/latch/\*lat.00\*
    Is globally unmatched affecting 1 compare point(s):
        i:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1

-----------
r:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/fm_bb/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/a_int_reg[3][0]
    Matched with pin i:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/fm_bb/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/a_int_reg[3][0]
    Exists in the ref cone but not in the impl cone for 1 compare point(s):
        i:/WORK/wp45/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/fm_ret_fwmc_1_1_323/u_disptop/U_DISPD_LAI053/u_pnlmemctl/u_imgmemctl/u_abc4x4_dec/prl_ari_0__u_div/U_DIV/bdramclk1x_r_REG42_S1

-----------
--------------------------------
Found 1 Rejected Guidance Command
--------------------------------
The rejection of some SVF guidance commands will almost invariably
cause verification failures. For more information use:
        report_svf_operation -status rejected -command command_name
--------------------------------
reg_constant
-----------
--------------------------------
****************************************************************************************
Analysis Completed
1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析report,首先logic cone 有两个unmatched inputs：一个是gating, 但是发现这个gating并不影响func,而且ref/imp reg的CK 都是r,所以这个gating并不是导致failing points的原因；另一个是fm_bb，这个存在于ref里，也正是由于这个fm_bb的output是1才导致SD/AD pin fail。
接着，有一个guidance cmd 被rejected：guide_reg_constant，这是svf里把reg标为constant 0/1 的操作。联想到imp里SD/AD pin的startpoints 都是constant 0, 所以应该是DC做reg_constant 操作，将failing point 前的reg 标为0，但是这个操作因为某种原因被formality rejected, 从而ref 里引入了fm_bb。那么到底是为何被reject? report_svf_operation report 截取一段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## SVF Operation 945483 (Line: 8463522) - reg_constant.  Status: rejected
## Operation Id: 945483
guide_reg_constant \
  -design { wp45 } \
  -replaced { svfTrue } \
  { u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1 } \
  { 0 } 

Info:  guide_reg_constant 945483 (Line: 8463522) Cannot find master reference cell 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1'.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因就是：&lt;strong&gt;cannot find master reference cell&lt;/strong&gt;。居然没有这个cell?那它又是哪来的？查找svf file，发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Operation Id: 875794
guide_retiming \
  -design { wp45 } \
  -direction { forward } \
  -libCell { FM_FORK } \
  -input { :__tmp__name___1392479 } \
  -output { :u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1 } 

## Operation Id: 945483
guide_reg_constant \
  -design { wp45 } \
  -replaced { svfTrue } \
  { u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1 } \
  { 0 } 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个reg是经过forward retime后命名为此，随后DC觉得它是个constant 0 reg。constant0 reg可能是因为D pin tie 0,也可能是reset pin tie 1 导致的。那么DC是怎么处理这些constant register 的呢？查找DC log,发现如下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm3/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm2/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm1/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
Information: The register 'u_moetop/u_imetop/u_imemap/u_imetf2_2p/u_ime_norm0/u_mult_0/mult_x_1/bimeclk_r_REG123_S1' is a constant and will be removed. (OPT-1206)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;真相大白：&lt;strong&gt;默认情况下，DC会remove constant register, 并在log里给出OPT-1206提示&lt;/strong&gt;。至此，终于找到failing root cause,下面就是针对问题找到解决方法了。DC 对constant register 的处理由以下3个变量控制，默认值都是true:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile_seqmap_propagate_constants:           Removes cells with a constant on the input.
compile_seqmap_propagate_high_effort:         Removes cells with a constant on the reset.
compile_seqmap_propagate_constants_size_only: Propagates constants through size_only cells.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;compile_seqmap_propagate_constants_size_only&lt;/code&gt; 是控制是否传递size_only/dont_touch attribute的constant reg 的constant value，而不是要remove size_only/dont_touch reg。&lt;/p&gt;

&lt;h4 id=&quot;13-slove&quot;&gt;1.3 Slove&lt;/h4&gt;
&lt;p&gt;所以，我们在compile前将这些变量设为false,问题应该就可以迎刃而解了。但是，难道我们要用没有remove constant reg的netlist做PR? 好吧，曲线救国：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;set var flase, RTL—&amp;gt; netlist1&lt;/li&gt;
  &lt;li&gt;set var true,   RTL—&amp;gt; netlist 2&lt;/li&gt;
  &lt;li&gt;formality, RTL VS netlist1&lt;/li&gt;
  &lt;li&gt;formality, netlist1 VS netlist2&lt;/li&gt;
  &lt;li&gt;PR with netlist2&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;case2&quot;&gt;Case2&lt;/h3&gt;
&lt;h4 id=&quot;21-problem&quot;&gt;2.1 Problem&lt;/h4&gt;
&lt;p&gt;综合完，RTL-Gate Formality inconclusive, 有33个points。原来这个module属于一个42bit除以9bit的除法器，每一位quotient的logic cone都很大，formality 很难比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;********************************* Verification Results *********************************
Verification INCONCLUSIVE
(Equivalence checking aborted due to complexity)
   ATTENTION: synopsys_auto_setup mode was enabled.
              See Synopsys Auto Setup Summary for details.
   ATTENTION: RTL interpretation messages were produced during link
              of reference design.
              Verification results may disagree with a logic simulator.
-----------------------------------------------------------------------
 Reference design: r:/WORK/***
 Implementation design: i:/WORK/***
 161129 Passing compare points
 33 Aborted compare points
 0 Unverified compare points
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;22-debug&quot;&gt;2.2 Debug&lt;/h4&gt;
&lt;p&gt;前文提到的方法我都一一试过:timeout-limit, datapath-effort, new tool version, set_verification_priority, 10多种alternative strategy 都没用……
难道真的是因为这个42bit/9bit 的除法器太大了，无论如何都无法过formality?
那么仅综合这个除法器能不能过呢？我尝试把这个除法器module摘出来，仅综合这个module，然后对这个module做formal check,奇迹出现了，居然SUCCESSED.&lt;/p&gt;
&lt;h4 id=&quot;23-solve&quot;&gt;2.3 Solve&lt;/h4&gt;
&lt;p&gt;最终，通过优先综合除法器design，再综合其它design, 才成功pass formal check.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;RTL-Gate LEC check 是一项很复杂的过程，通常需要在DC/formality里迭代完成，这是非常耗时的，所以formal check 的经验在此格外重要，大牛可能一眼就看出是什么原因，需要在综合时做何种设置；而吾类菜鸟就要慢慢debug,花费大量时间尝试各种可能。文中所述仅为本人在项目中积累的粗浅经验，有错请指正。&lt;strong&gt;不积跬步无以至千里&lt;/strong&gt;，不断积累，早日成大牛!&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="tool" /><category term="formality" /><category term="verification" /><summary type="html">Formality Formality® is an equivalence-checking (EC) solution that uses formal, static techniques to determine if two versions of a design are functionally equivalent.</summary></entry><entry><title type="html">Hello World</title><link href="http://localhost:4000/Hello-World/" rel="alternate" type="text/html" title="Hello World" /><published>2017-07-26T00:00:00+08:00</published><updated>2017-07-26T00:00:00+08:00</updated><id>http://localhost:4000/Hello-World</id><content type="html" xml:base="http://localhost:4000/Hello-World/">&lt;p&gt;第0篇blog,当然是献给&lt;code&gt;Hello World&lt;/code&gt;.
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id=&quot;为何写blog&quot;&gt;为何写blog?&lt;/h2&gt;
&lt;h3 id=&quot;1-更深刻地思考&quot;&gt;1. 更深刻地思考&lt;/h3&gt;
&lt;p&gt;写blog，是一次真正的思考过程。因为要写出来，所以你要有清晰的条理，合理的逻辑。当你在写作时，会深究前因后果，会比平时思考的更加深刻，更能提高你的逻辑思维能力。&lt;/p&gt;
&lt;h3 id=&quot;2-更深入地理解&quot;&gt;2. 更深入地理解&lt;/h3&gt;
&lt;p&gt;真正的理解，不是自己明白，而是能让别人明白。在别人请教你问题时，你也许会发现其实你的理解并不全面或并不正确；你给别人讲解的过程，也是你自己反思的过程，这个过程里你可能会有意外收获。写blog，这是一个像陌生人讲解的过程，如果他人能够认可你的解释，那才说明你真正地理解了。&lt;/p&gt;
&lt;h3 id=&quot;3-更持续地学习&quot;&gt;3. 更持续地学习&lt;/h3&gt;
&lt;p&gt;做技术相关的工作，怎么能不持续学习？信息时代，技术迭代更新的速度大大加快。不断地学习新知识和新技术是提高自身竞争的不二法门。&lt;/p&gt;
&lt;h3 id=&quot;4-更具体的记忆&quot;&gt;4. 更具体的记忆&lt;/h3&gt;
&lt;p&gt;只有大牛才能写blog? NO！不要害怕出错，这是个提高的过程。多年后，你可以从你的blog上看到你的成长，blog里记录了你菜鸟时期的傻逼问题，也记录了你成长之后的深邃理解，这就是你自己的记忆。&lt;/p&gt;

&lt;h2 id=&quot;写什么&quot;&gt;写什么？&lt;/h2&gt;
&lt;h3 id=&quot;1-工作相关的技术问题&quot;&gt;1. 工作相关的技术问题&lt;/h3&gt;
&lt;p&gt;主要记录、总结、反思工作/学习过程中碰到的相关技术问题。IC phyical design 是个复杂的过程，工作过程中碰到的知识点有很多很杂。&lt;/p&gt;
&lt;h3 id=&quot;2-其它方面的兴趣爱好&quot;&gt;2. 其它方面的兴趣爱好&lt;/h3&gt;
&lt;p&gt;类似于学习笔记吧，可能会包括java,python等，&lt;/p&gt;
&lt;h3 id=&quot;3-生活吐槽&quot;&gt;3. 生活吐槽？&lt;/h3&gt;
&lt;p&gt;貌似github page不能加password protect，待定。&lt;/p&gt;

&lt;h2 id=&quot;怎么写&quot;&gt;怎么写？&lt;/h2&gt;
&lt;p&gt;就是github + jekyll 搭个自己的blog了。用markdown 写blog，github pg 编译成静态网页，还能免费托管在github，完美。&lt;br /&gt;
jekyll 基于ruby, 配合github page使用过程中还是有很多坑的，还好大多数都已经有前人替我们趟过，然后无私地写blog分享出来，share！&lt;br /&gt;
看着自己的blog从一无所有，到navigation、footer、theme、code hlighlight，再到disqus comment,google analytics，还有不断地调整css 达到自己想要的效果，真的是很有成就感啊:smile:&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;我就是自己的读者，即使是唯一的，我也会keep writing…&lt;/p&gt;</content><author><name>Leon Sun</name></author><category term="杂谈" /><summary type="html">第0篇blog,当然是献给Hello World.</summary></entry></feed>